var url = require('url');
var querystring = require('querystring');
var stream = require('stream');

var Message = require('./modules/message');
var request = require('./modules/request');
var tryJSON = require('./modules/tryJSON');
var vkUtils = require('./modules/utils');
var methods = require('./methods.json');

var globalOptions = {
    filename: 'photo.png',
    cart_interval: 334,
    timeout: 120000,
    host: 'api.vk.com',
    method: 'POST',
    body: {
        v: '5.69'
    },
    headers: {
        'user-agent': 'npm/VK-Promise'
    },
    longpoll: {
        act: 'a_check',
        wait: 25,
        mode: 234,
        version: 1
    }
};

function VK(access_token, options) {
    var global_request_id = 0;
    var defaultOptions = Object.assign({}, globalOptions, options);
    var defaultData = Object.assign({ headers: defaultOptions.headers }, defaultOptions.body);

    // Секция отвечающая за запросы
    function vk(method, data) {
        var args = Array.from(arguments);
        args[0] = Object.assign({}, defaultData);
        data = Object.assign.apply(null, args);

        vk.on('before_request', {
            method: method,
            data: data
        });

        if (!data.ignore_cart && vk.cart.timer !== false) {
            return new Promise(function waitExecute(resolve, reject) {
                delete data.headers;
                vk.cart.list.push({
                    method: method,
                    data: data,
                    resolve: resolve,
                    reject: reject
                });
            });
        }

        delete data.ignore_cart;
        if (vk.cart.timer === false) vk.cart.init();

        data.access_token = data.access_token || access_token;

        var headers = Object.assign({}, data.headers);
        delete data.headers;

        var request_id = global_request_id++;
        var ping = Date.now();

        vk.on('request', {
            method: method,
            request_id: request_id,
            headers: headers,
            data: data
        });

        return request(Object.assign({}, defaultOptions, {
            path: '/method/' + method,
            headers: headers
        }), querystring.stringify(data))
            .then(tryJSON)
            .then(function onJSON(body) {
                if (body.error) throw body.error;
                vk.on('response', body.response, {
                    method: method,
                    request_id: request_id,
                    ping: Date.now() - ping
                });
                return method == 'execute' ? body : body.response;
            })
            .catch(function onError(error) {
                if (error.error_code == 6 && data.retry !== false) {
                    return new Promise(function retryRequest(resolve, reject) {
                        if (vk.cart.timer === false) vk.cart.init();
                        vk.on('retry', { method: method });
                        vk.cart.list.unshift({
                            method: method,
                            data: data,
                            resolve: resolve,
                            reject: reject
                        });
                    });
                } else if (error.error_code == 14 && data.reject_captcha !== true) {
                    return new Promise(function onCaptcha(resolve, reject) {
                        vk.on('captcha', {
                            captcha_img: error.captcha_img,
                            method: method,
                            data: data,
                            error: error,
                            submit: function submit(captcha_key) {
                                vk(method, Object.assign(data, {
                                    captcha_sid: error.captcha_sid,
                                    captcha_key: captcha_key
                                })).then(resolve, reject);
                            }
                        });
                    });
                }
                var errorData = {
                    error: error,
                    method: method,
                    data: data,
                    retry: vk.bind(null, method, data)
                };

                vk.on('error', errorData);
                throw errorData;
            });
    }

    // region event manager
    vk.listeners = {
        '*': []
    };

    vk.on = function onEvent(eventName, data, additionalData) {
        if (!vk.listeners[eventName]) vk.listeners[eventName] = [];
        if (typeof data == 'function') {
            vk.listeners[eventName].push(data);
        } else {
            vk.listeners[eventName]
                .concat(vk.listeners['*'])
                .forEach(function emit(listener) {
                    if (typeof listener !== 'function') return;
                    listener(Object.assign({
                        data: data,
                        eventName: eventName
                    }, additionalData), data);
                });
        }
        return data;
    };
    // endregion

    // region LongPoll
    vk.longpoll = {
        exit: false,
        started: false,
        stop: function stopLongpoll(callback) {
            return new Promise(function stopLongpoll(resolve) {
                vk.longpoll.exit = function stopLongpoll(data) {
                    resolve(data);
                    if (callback) callback(data);
                };

                if (vk.longpoll.started) return;

                vk.longpoll.exit({
                    error: 'stop longpoll'
                });
            });
        },
        start: function startLongpoll(opts) {
            vk.longpoll.started = true;
            opts = opts || {};
            opts.method = 'messages.getLongPollServer';

            if (opts.group_id) {
                opts.method = 'groups.getLongPollServer';
            }

            return vk(opts.method, Object.assign({
                use_ssl: 1,
                need_pts: 1
            }, opts)).then(function onResponse(data) {
                return vk.longpoll.listen(Object.assign(data, defaultOptions.longpoll, opts));
            }).catch(function onError(e) {
                vk.on('LongPollError', e);
            });
        },
        listen: function getUpdates(data) {
            if (!data.server) throw { error: 'Invalid server', data };
            vk.on('LongPollRequest', data);

            if (!/^https?:\/\//.test(data.server)) {
                data.server = 'https://' + data.server;
            }

            return request(data.server + '?' + querystring.stringify(data))
                .then(tryJSON)
                .then(function parseUpdates(body) {
                    vk.on('LongPollResponse', body);
                    if (body.error || body.failed) {
                        throw body;
                    } else if (body.updates) {
                        body.updates.forEach(vk.on.bind(null, 'update'));
                        data.ts = body.ts;
                    }
                    if (vk.longpoll.exit) throw data;
                    return vk.longpoll.listen(data);
                }).catch(function onError(e) {
                    if (vk.longpoll.exit) {
                        if (typeof vk.longpoll.exit == 'function') vk.longpoll.exit(e);
                        vk.longpoll.exit = false;
                        vk.longpoll.started = false;
                        return vk.on('LongPollStop', e);
                    }
                    vk.on('LongPollError', e);
                    return vk.longpoll.start(data);
                });
        }
    };
    // endregion

    // region callback_api
    vk.callback_api = {
        getCallback: function getCallback(key, secret, data) {
            return function onRequest(req, res) {
                if (req.method !== 'POST') {
                    return req.connection.destroy();
                }

                var body = '';
                req.on('data', function onData(chunk) {
                    if (body.length > 1e6) {
                        body = null;
                        req.connection.destroy();
                    } else {
                        body += chunk;
                    }
                });
                req.on('end', function onClose() {
                    try {
                        body = JSON.parse(body);
                        body.$ = {
                            key: key,
                            data: data,
                            req: req,
                            res: res
                        };
                    } catch (e) {
                        body = null;
                        return req.connection.destroy();
                    }
                    if (secret && secret !== body.secret) {
                        return res.end('Invalid secret');
                    } else if (body.type == 'confirmation') {
                        vk.on('confirmation', body.object, {
                            reject: function onReject(description) {
                                body.$.key = description;
                            }
                        });
                        return res.end(body.$.key);
                    } else {
                        vk.on(body.type, body, {
                            ok: function onResponse(code) {
                                res.end(code || 'OK');
                            }
                        });
                    }
                });
            };
        },
        setServer: function setServer(opts) {
            return vk('groups.getCallbackConfirmationCode', opts).then(function onResponse(r) {
                if (!opts.serverModule) {
                    return Promise.reject('Invalid serverModule');
                }

                if (!opts.listen) {
                    return Promise.reject('Invalid server listener');
                }

                opts.code = r.code;
                var serverOpts = [opts.code];
                if (opts.secret_key) serverOpts.push(opts.secret_key);
                if (opts.serverData) serverOpts.push(opts.serverData);

                opts.callback = vk.callback_api.getCallback.apply(null, serverOpts);
                opts.server = opts.serverModule(opts.callback);

                return new Promise(function startListen(resolve, reject) {
                    opts.server.listen(opts.listen, function onError(err) {
                        if (err) {
                            return reject(err);
                        }
                        resolve();
                    });
                });
            }).then(function onListen() {
                return vk('groups.getCallbackServers', opts);
            }).then(function onResponse(res) {
                var similarServer = res.items.find(function findSimilarServer(x) {
                    return x.url == opts.url;
                });

                if (similarServer && similarServer.status == 'ok') {
                    return {
                        server_id: similarServer.id
                    };
                }

                opts.title = opts.title || opts.url.replace(/^.+?\/\//, '').substr(0, 14);

                if (!similarServer) {
                    return vk('groups.addCallbackServer', opts);
                }

                opts.server_id = similarServer.id;

                return vk('groups.editCallbackServer', opts);
            }).then(function onEditResponse(r) {
                opts.server_id = r.server_id;
                return vk('groups.setCallbackSettings', opts);
            }).then(function onResponse() {
                return opts;
            });
        },
        initAllListeners: function initAllListeners() {
            vk.on('*', function onCallbackEvent(event) {
                if (!vk.listeners[event.eventName]) vk.listeners[event.eventName] = [];
                if (!event.ok || vk.listeners[event.eventName].length) return;
                event.ok();
            });
        }
    };
    vk.init_callback_api = vk.callback_api.getCallback;
    // endregion

    // region cart manager
    vk.cart = {
        list: [],
        timer: false,
        execute: false,
        init: function cartInit(interval) {
            vk.cart.timer = setInterval(function onCartTick() {
                if (!vk.cart.list.length) {
                    if (!defaultOptions.disable_auto_deinit_cart) vk.cart.deinit();
                    return;
                }
                var req = vk.cart.list.shift();

                if (vk.cart.execute && vk.cart.list.length && req.method !== 'execute') {
                    req = vk.build_execute_request(req, vk.cart.list);
                }

                vk(req.method, req.data, {
                    ignore_cart: true
                }).then(req.resolve, req.reject);
            }, interval || defaultOptions.cart_interval);
        },
        deinit: function cartDeinit() {
            clearInterval(vk.cart.timer);
            vk.cart.timer = false;
        }
    };

    vk.requestStringify = function requestStringify(method, data) {
        delete data.reject_captcha;
        return 'API.' + method + '(' + JSON.stringify(data) + ')';
    };

    vk.build_execute_request = function buildExecuteRequest(request, cart) {
        var limit = 4000;

        if (vk.requestStringify(request.method, request.data).length > limit) {
            return request;
        }

        var code = 'return [' + vk.requestStringify(request.method, request.data),
            executeCart = [request];


        var requestCode = '';

        for (var i = 0; i < cart.length; i++) {
            if (/^execute/.test(cart[i].method) || cart[i].data.ignore_execute_cart || cart[i].data.access_token) continue;
            requestCode = ',' + vk.requestStringify(cart[i].method, cart[i].data);
            if (code.length + requestCode.length > limit || executeCart.length >= 25) break;
            code += requestCode;
            executeCart.push(cart.splice(i, 1)[0]);
            i--;
        }

        code += '];';

        return {
            method: 'execute',
            data: {
                code: code
            },
            resolve: function parseResponse(r) {
                if (!r.response) throw r;
                var error_index = 0;
                r.response.forEach(function resolveResponse(i, ii) {
                    if (i) {
                        return executeCart[ii].resolve(i);
                    } else if (r.execute_errors && r.execute_errors[error_index]) {
                        executeCart[ii].reject(r.execute_errors[error_index]);
                        error_index++;
                    } else {
                        return executeCart[ii].resolve(i);
                    }
                });
            },
            reject: function rejectAll(e) {
                executeCart.forEach(function reject(req) {
                    req.reject(e);
                });
            }
        };
    };

    vk.init_execute_cart = function initExecuteCart(interval) {
        vk.cart.execute = true;
        vk.cart.init(interval);
    };

    // Автоматический перебор с offset
    vk.getAll = function getAll(method, data, onstep) {
        return new Promise(function buildRequest(resolve, reject) {
            var response = [];
            data = Object.assign({
                count: 100
            }, data);

            (function next(offset) {
                var max_requests = 25,
                    requests = [];

                while (max_requests--) {
                    requests.push('API.' + method + '(data + {offset: ' + offset + '})');
                    offset += data.count;
                }

                vk('execute', {
                    access_token: data.access_token || access_token,
                    code: 'var data = ' + JSON.stringify(data || {}) + ';' +
                        'return [' + requests.join(',') + '];'
                }).then(function onResponse(r) {
                    if (!r.response[0].items) throw 'unsuppodted method or invalid data';

                    var items = r.response.reduce(function concatAll(pv, cv) {
                        return pv.concat(cv.items);
                    }, []);

                    response = response.concat(items);

                    if (onstep) {
                        onstep({
                            offset: offset,
                            count: r.response[0].count,
                            new_items: items,
                            all_items: response
                        });
                    }
                    if (offset >= r.response[0].count || offset >= data.max_offset) {
                        return resolve(response);
                    }
                    next(offset);
                }).catch(reject);
            })(0);
        });
    };
    // endregion

    // region auth
    vk.setToken = function setToken(newToken) {
        access_token = newToken;
    };

    vk.auth = function Auth(data) {
        return request('https://oauth.vk.com/token', Object.assign({
            '2fa_supported': 1,
            grant_type: 'password',
            scope: 'all',
            client_id: '2274003',
            client_secret: 'hHbZxrka2uZ6jB1inYsH'
        }, data)).then(vk.tryJSON).then(function onResponse(r) {
            if (!r.access_token) throw r;
            vk.setToken(r.access_token);
            return r;
        });
    };
    // endregion

    // region upload
    vk.upload = function upload(get_server_method, save_method, data) {
        if (data && !data.files && (data.pipe || data.buffer) || Buffer.isBuffer(data)) {
            if (Buffer.isBuffer(data)) {
                data = {
                    buffer: data
                };
            }
            if (/^photos\.getWall|Owner|Messages/.test(get_server_method)) {
                data = {
                    files: {
                        photo: data
                    }
                };
            } else if (get_server_method == 'photos.getUploadServer') {
                data = {
                    files: {
                        file1: data
                    }
                };
            } else if (get_server_method == 'video.save') {
                data = {
                    files: {
                        video_file: data
                    }
                };
            } else {
                data = {
                    files: {
                        file: data
                    }
                };
            }
        }

        if (!data || !data.files) {
            Promise.reject({
                retry: vk.upload.bind(null, get_server_method, save_method, data),
                error: {
                    error_code: -400,
                    error_msg: 'Nothing to upload'
                }
            });
        }

        return vk(get_server_method, data.get || {})
            .then(function onServerData(r) {
                var boundary =
                    (Math.random() * 1e18).toString(16) +
                    (Math.random() * 1e18).toString(16);

                vk.on('upload.get_server', r.upload_url);
                var save_options = url.parse(r.upload_url);
                save_options.method = 'POST';
                save_options.headers = {
                    'Content-Type': 'multipart/form-data;boundary=' + boundary
                };
                var rs = new stream.PassThrough();

                var files = Object.keys(data.files);
                (function sendPart() {
                    if (!files.length) {
                        rs.push('\n--' + boundary + '--\n');
                        vk.on('upload.end', true);
                        return rs.push(null);
                    }
                    var name = files.shift();
                    var part = data.files[name];

                    if (!part.filename && !part.path && part.req && part.req.path) {
                        part.filename = part.req.path.replace(/(.+)(\/|\\)/, '').replace(/\?.+$/, '');
                    }
                    if (!part.filename) {
                        part.filename = part.path ? part.path.replace(/(.+)(\/|\\)/, '') : defaultOptions.filename;
                    }

                    vk.on('upload.part', part);
                    rs.push('\n--' + boundary + '\nContent-Disposition: form-data; name="' + name + '"; filename="' + part.filename + '"\n\n');
                    if (part.readable) {
                        part.pipe(rs, {
                            end: false
                        });
                        part.on('end', function onEnd() {
                            vk.on('part_end', part);
                            sendPart();
                        });
                    } else if (part.buffer) {
                        rs.push(part.buffer);
                        sendPart();
                    } else {
                        console.warn('VK.upload: unsupported data type');
                        sendPart();
                    }
                })();

                return request(save_options, rs);
            }).then(tryJSON)
            .then(function onUploadDone(body) {
                vk.on('upload.save', body);
                if (body.error) {
                    throw {
                        retry: vk.upload.bind(vk, get_server_method, save_method, data),
                        error: body.error
                    };
                }
                if (save_method == 'return') return body;
                return vk(save_method, Object.assign(data.save || {}, body));
            });
    };

    vk.upload.chatPhoto = function uploadChat(opts) {
        return vk.upload('photos.getChatUploadServer', 'return', opts)
            .then(function onUploadDone(r) {
                return vk('messages.setChatPhoto', {
                    file: r.response
                });
            });
    };

    // region upload map
    vk.upload.photo = vk.upload.bind(null, 'photos.getUploadServer', 'photos.save');
    vk.upload.wallPhoto = vk.upload.bind(null, 'photos.getWallUploadServer', 'photos.saveWallPhoto');
    vk.upload.ownerPhoto = vk.upload.bind(null, 'photos.getOwnerPhotoUploadServer', 'photos.save');
    vk.upload.messagesPhoto = vk.upload.bind(null, 'photos.getMessagesUploadServer', 'photos.saveMessagesPhoto');
    vk.upload.marketPhoto = vk.upload.bind(null, 'photos.getMarketUploadServer', 'photos.saveMarketPhoto');
    vk.upload.marketAlbumPhoto = vk.upload.bind(null, 'photos.getMarketAlbumUploadServer', 'photos.saveMarketAlbumPhoto');
    vk.upload.audio = vk.upload.bind(null, 'audio.getUploadServer', 'audio.save');
    vk.upload.video = vk.upload.bind(null, 'video.save', 'video.save');
    vk.upload.doc = vk.upload.bind(null, 'docs.getUploadServer', 'docs.save');
    vk.upload.wallDoc = vk.upload.bind(null, 'docs.getWallUploadServer', 'docs.save');
    vk.upload.groupCover = vk.upload.bind(null, 'photos.getOwnerCoverPhotoUploadServer', 'photos.saveOwnerCoverPhoto');

    vk.upload.widgetsAppImage = vk.upload.bind(null, 'appWidgets.getAppImageUploadServer', 'appWidgets.saveAppImage');
    vk.upload.widgetsGroupImage = vk.upload.bind(null, 'appWidgets.getGroupImageUploadServer', 'appWidgets.saveGroupImage');

    vk.upload.storiesPhoto = vk.upload.bind(null, 'stories.getPhotoUploadServer', 'return');
    vk.upload.storiesVideo = vk.upload.bind(null, 'stories.getVideoUploadServer', 'return');

    vk.upload.photos = vk.upload.photo;
    vk.upload.docs = vk.upload.doc;
    vk.upload.wallDocs = vk.upload.wallDoc;
    vk.upload.wallPhotos = vk.upload.wallPhoto;
    // endregion
    // endregion

    // region event router
    vk.createMessage = function createMessage(messageData) {
        var message = new Message(messageData);

        Object.defineProperty(message, 'vk', {
            enumerable: false,
            get: function getVK() {
                return vk;
            }
        });

        return message;
    };

    function onMessage(event) {
        if (event.data.type && event.data.object) {
            var msg = event.data.object;
            msg.out = event.data.type == 'message_reply';
            msg.$   = event.data;

            vk.on('message', vk.createMessage(msg), {
                ok: function onResponse(code) {
                    if (event.ok) {
                        event.ok(code || 'OK');
                    }
                }
            });
            return;
        }

        if (event.data[0] !== 4) {
            return;
        }

        var message = Message.parseLongPoll(event.data);
        message = vk.createMessage(message);
        vk.on('message', message);
    }

    vk.on('message_reply', onMessage);
    vk.on('message_new',   onMessage);
    vk.on('update',        onMessage);
    // endregion

    // Создаем секции и фунции методов
    methods.forEach(function addMethod(method) {
        if (method.indexOf('.') == -1) {
            vk[method] = vk.bind(null, method);
        } else {
            method = method.split('.');
            if (!vk[method[0]]) vk[method[0]] = {};
            vk[method[0]][method[1]] = vk.bind(null, method.join('.'));
        }
    });

    return Object.assign(vk, {
        request: request,
        tryJSON: tryJSON,
        options: defaultOptions,
    }, vkUtils);
}

VK.methods = methods;
Object.assign(VK, vkUtils);

module.exports = VK;
